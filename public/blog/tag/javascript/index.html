<html lang="en">
    <head>
        <meta charset="UTF-8">
        
            <title>Posts tagged &#39;javascript&#39; | gelatindesign</title>
        

        <link rel="shortcut icon" href="/assets/images/icon.png">

        <link media="all" type="text/css" rel="stylesheet" href="/assets/styles/master.css">

        <script>
            (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
            m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
            })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

            ga('create', 'UA-18813637-1', 'gelatindesign.co.uk');
            ga('send', 'pageview');

        </script>

        <script src="/assets/scripts/d3.v3.min.js" charset="utf-8"></script>
        <script src="/assets/scripts/nv.d3.min.js" charset="utf-8"></script>
    </head>
    <body>
        
            
        

        <a href="/"><img class="header" src="/assets/images/logo-header.png" alt="Posts tagged &#39;javascript&#39;"></a>

        <div id="site-content">
            
    
    <article class="page">
        <header>
            <h1>Posts tagged &#39;javascript&#39;</h1>
        </header>

        
    </article>


    <section class="post-list">
        
            <article class="post">
    <header>
        <h1><a href="/blog/post/creating-a-blog-with-metalsmith">Creating a blog with Metalsmith</a></h1>

        <span class="date">24th May, 2014</span>
    </header>

    <p>I&#39;ve been looking at converting this site to use a static-site generator. Prior to this I&#39;ve been using a simple custom blog on top of Laravel. As much as I love Laravel, it seems a touch pointless to have all this dynamic code behind what is just static content pages.</p>
<p>With that in mind I had a look around at what the available options were. Jekyll seemed like a good choice and I began working on porting my content to it. However I wasn&#39;t particuarly sold, not sure why I just didn&#39;t feel happy using it. I wanted more control and to organise my files how I wanted.</p>
<p>Yesterday I saw a retweet about <a href="http://metalsmith.io">Metalsmith</a> which looked very similar to <a href="/blog/post/easily-build-assets-with-gulpjs">Gulpjs which I am already a big fan of</a>. I started a few hours ago writing my build script and porting my content and now not long later it&#39;s all done.</p>
<p>I did have to do some work to get things how I wanted. Metalsmith is very hands-off so if you want list pages, pagination, tag pages etc you will have to write these yourself.</p>
<p>Fortunately it&#39;s dead simple to do. Plugins are easy to write and you can just manipulate the files being generated. So for example a tagging plugin could be written as so:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> metalsmith  = <span class="hljs-built_in">require</span>(<span class="hljs-string">'metalsmith'</span>),
    collections = <span class="hljs-built_in">require</span>(<span class="hljs-string">'metalsmith-collections'</span>);

metalsmith(__dirname)

    <span class="hljs-comment">// group together all files in the `/blog/` directory as posts</span>
    .use(collections({
        posts: {
            pattern: <span class="hljs-string">'blog/*'</span>,
            sortBy: <span class="hljs-string">'date'</span>,
            reverse: <span class="hljs-literal">true</span>,
        }
    }))

    <span class="hljs-comment">// generate the tag listing pages</span>
    .use(blogTagLists)

    <span class="hljs-comment">// build</span>
    .build(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(err)</span> </span>{
        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;
    });

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">blogTagLists</span><span class="hljs-params">(files, metalsmith, done)</span> </span>{
    <span class="hljs-keyword">var</span> tags = {};

    <span class="hljs-comment">// loop the posts collection, creating new groups on the tags</span>
    <span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> metalsmith.data.posts) {
        <span class="hljs-keyword">for</span> (t <span class="hljs-keyword">in</span> metalsmith.data.posts[p].tags) {
            tag = metalsmith.data.posts[p].tags[t];
            <span class="hljs-keyword">if</span> (! tags[tag]) {
                tags[tag] = [];
            }

            tags[tag].push(metalsmith.data.posts[p]);
        }
    }

    <span class="hljs-comment">// loop the tags and create a new index file for each tag</span>
    <span class="hljs-keyword">for</span> (tag <span class="hljs-keyword">in</span> tags) {
        files[<span class="hljs-string">'blog/tag/'</span> + tag + <span class="hljs-string">'/index.md'</span>] = {
            template: <span class="hljs-string">'list.html'</span>,
            mode: <span class="hljs-string">'0644'</span>,
            contents: <span class="hljs-string">''</span>,
            title: <span class="hljs-string">"Posts tagged '"</span> + tag + <span class="hljs-string">"'"</span>,
            posts: tags[tag],
        }
    }

    done();
}
</code></pre>
<p>You can see my full <a href="http://github.com/lsjroberts/gelatin-design/tree/master/build.js">build.js file here</a> along with the rest of the code for this site.</p>
<p>If you&#39;re looking for a static-site generator which gives you a lot of control then I really recommend <a href="http://metalsmith.io">Metalsmith</a>.</p>
<hr>
<p>What are your thoughts on Metalsmith? Do you prefer Jekyll or another static-site generator? Leave your comments below.</p>


    <footer>
        <nav class="tags">
            
                <a class="tag tag-coding" href="/blog/tag/coding">coding</a></li>
            
                <a class="tag tag-javascript" href="/blog/tag/javascript">javascript</a></li>
            
                <a class="tag tag-nodejs" href="/blog/tag/nodejs">nodejs</a></li>
            
                <a class="tag tag-metalsmith" href="/blog/tag/metalsmith">metalsmith</a></li>
            
                <a class="tag tag-jekyll" href="/blog/tag/jekyll">jekyll</a></li>
            
        </nav>

        <a class="comments-link" href="/blog/post/creating-a-blog-with-metalsmith#comments">Comments</a>
    </footer>
</article>
        
            <article class="post">
    <header>
        <h1><a href="/blog/post/coffeescript-is-objectively-better-than-javascript">Coffeescript is objectively better than javascript</a></h1>

        <span class="date">17th February, 2014</span>
    </header>

    <p>I can see no reason why anyone would use javascript over <a href="http://coffeescript.org/">coffeescript</a>. The latter is without a doubt objectively better. Sure, it will take a bit of time to learn, perhaps a day or two. But if you are in the web development game you should be learning every single day. One day off and you are behind and have to play catch up.</p>
<p>The time investment is clearly worth it.</p>
<!-- more -->

<h2 id="it-s-just-better-looking-javascript">It&#39;s just better looking javascript</h2>
<p>I got driven to coffeescript through my frustration with the many opinions and methods of just simply writing class-based javascript. Prototypes work great but are messy, and inheritence is implemented in a slightly odd fashion.</p>
<p>Clean code is good code is fun code.</p>
<p>So how do you write a class in coffeescript? One line.</p>
<pre><code class="lang-coffeescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
</code></pre>
<p>Compare that to the generated javascript:</p>
<pre><code class="lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> Foo;

  Foo = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span><span class="hljs-params">()</span> </span>{}

    <span class="hljs-keyword">return</span> Foo;

  })();

}).call(<span class="hljs-keyword">this</span>);
</code></pre>
<p>There&#39;s definitely some boilerplate going on, but what about something a touch less trivial?</p>
<pre><code class="lang-coffeescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Foo</span></span>
    constructor: (<span class="hljs-annotation">@who</span>) -&gt;

    say: -&gt;
        console.log(<span class="hljs-symbol">'Hello</span> ' + <span class="hljs-annotation">@who</span> + '!')

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Foo</span></span>
    say: -&gt;
        console.log(<span class="hljs-symbol">'Good</span> evening ' + <span class="hljs-annotation">@who</span> + '!')
</code></pre>
<p>Looking at the generated javascript it&#39;s hard to deny the superiority of coffeescript.</p>
<pre><code class="lang-javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> Bar, Foo,
    __hasProp = {}.hasOwnProperty,
    __extends = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(child, parent)</span> </span>{ <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> parent) { <span class="hljs-keyword">if</span> (__hasProp.call(parent, key)) child[key] = parent[key]; } <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ctor</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">this</span>.constructor = child; } ctor.prototype = parent.prototype; child.prototype = <span class="hljs-keyword">new</span> ctor(); child.__super__ = parent.prototype; <span class="hljs-keyword">return</span> child; };

  Foo = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span><span class="hljs-params">(who)</span> </span>{
      <span class="hljs-keyword">this</span>.who = who;
    }

    Foo.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello '</span> + <span class="hljs-keyword">this</span>.who + <span class="hljs-string">'!'</span>);
    };

    <span class="hljs-keyword">return</span> Foo;

  })();

  Bar = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(_super)</span> </span>{
    __extends(Bar, _super);

    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Bar</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> Bar.__super__.constructor.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

    Bar.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Good evening '</span> + <span class="hljs-keyword">this</span>.who + <span class="hljs-string">'!'</span>);
    };

    <span class="hljs-keyword">return</span> Bar;

  })(Foo);

}).call(<span class="hljs-keyword">this</span>);
</code></pre>
<p>Really the only thing going against coffeescript is that it needs to be compiled. But using <a href="/post/easily-build-assets-with-gulpjs">a build tool like gulpjs</a> solves that. Indeed, compiling to javascript is one of it&#39;s greatest strengths. You get the benefit of a nicer, cleaner language and complete compatibility with all browsers.</p>
<p>There&#39;s far more to coffeescript as well, things like looping over array comprehensions:</p>
<pre><code class="lang-coffeescript"><span class="hljs-built_in">console</span>.log fruit <span class="hljs-keyword">for</span> fruit <span class="hljs-keyword">in</span> [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'banana'</span>, <span class="hljs-string">'grape'</span>]
</code></pre>
<p>Block regular expressions:</p>
<pre><code class="lang-coffeescript">OPERATOR = <span class="hljs-comment">/// ^ (</span>
  ?: [-=]&gt;             <span class="hljs-preprocessor"># function</span>
   | [-+*/%&lt;&gt;&amp;|^!?=]=  <span class="hljs-preprocessor"># compound assign / compare</span>
   | &gt;&gt;&gt;=?             <span class="hljs-preprocessor"># zero-fill right shift</span>
   | ([-+:])\<span class="hljs-number">1</span>         <span class="hljs-preprocessor"># doubles</span>
   | ([&amp;|&lt;&gt;])\<span class="hljs-number">2</span>=?      <span class="hljs-preprocessor"># logic / shift</span>
   | \?\.              <span class="hljs-preprocessor"># soak access</span>
   | \.{<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}           <span class="hljs-preprocessor"># range or splat</span>
) <span class="hljs-comment">///</span>
</code></pre>
<p>Function argument splats:</p>
<pre><code class="lang-coffeescript">foo = (<span class="hljs-keyword">first</span>, rest...) -&gt;
    console.<span class="hljs-built_in">log</span> <span class="hljs-keyword">first</span>, rest

# console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'a'</span>, [<span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>])
foo(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>)
</code></pre>
<p>And <a href="http://coffeescript.org">much more</a>.</p>
<p>The cleanliness of coffeescript allows you to write large applications and keep on top of it. With all redundant syntax removed it is far easier to see what your code is actually doing. Making your workflow more fun and your code better.</p>


    <footer>
        <nav class="tags">
            
                <a class="tag tag-coding" href="/blog/tag/coding">coding</a></li>
            
                <a class="tag tag-javascript" href="/blog/tag/javascript">javascript</a></li>
            
                <a class="tag tag-coffeescript" href="/blog/tag/coffeescript">coffeescript</a></li>
            
        </nav>

        <a class="comments-link" href="/blog/post/coffeescript-is-objectively-better-than-javascript#comments">Comments</a>
    </footer>
</article>
        
            <article class="post">
    <header>
        <h1><a href="/blog/post/clean-your-html-with-jade">Clean your HTML with Jade</a></h1>

        <span class="date">16th February, 2014</span>
    </header>

    <p>As fundamental as html is to the web it is a bit of an ugly character. Angular brackets are a particular eyesore.</p>
<p><a href="http://jade-lang.com">Jade</a> is a terse almost python-like html templating language. It is primarily a nodejs package, but there are compilers for <a href="http://stackoverflow.com/questions/13355137/php-jade-template-parser">PHP</a> and other languages as well.</p>
<!-- more -->

<p>It has a wonderfully basic syntax:</p>
<pre><code class="lang-jade">doctype html
html
    head
        title Hello World
        link(<span class="hljs-preprocessor">rel</span>=<span class="hljs-string">"stylesheet"</span>, href=<span class="hljs-string">"build/styles/combined.css"</span>)
    body
        <span class="hljs-keyword">div</span>.container
            p Hello World
</code></pre>
<h2 id="layouts-and-blocks">Layouts and blocks</h2>
<p>Jade allows you to create layouts and extend them for your different views:</p>
<pre><code class="lang-jade"><span class="hljs-comment">// layouts/master.jade</span>
body
    <span class="hljs-keyword">block</span> content
<span class="hljs-comment">{% endhighlight %}</span>

<span class="hljs-comment">{% highlight jade %}</span>
<span class="hljs-comment">// index.jade</span>
extends layouts/master

<span class="hljs-keyword">block</span> content
    header.hero
        h1 Hello World
</code></pre>
<h2 id="use-mixins-to-power-your-views">Use mixins to power your views</h2>
<p>Forms are probably the lamest thing to write in HTML, it can become a bore rather quickly. Using jade mixins you can speed this process up and cleanly define your form without all the verbosity.</p>
<pre><code class="lang-jade">// mixins/form.jade
<span class="hljs-keyword">mixin</span> form(action, <span class="hljs-keyword">method</span>)
    unless <span class="hljs-keyword">method</span>
        - <span class="hljs-keyword">method</span>= <span class="hljs-string">"get"</span>
    form(action= action, <span class="hljs-keyword">method</span>= <span class="hljs-keyword">method</span>)
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">block</span>
            <span class="hljs-keyword">block</span>
        <span class="hljs-keyword">else</span>
            p <span class="hljs-type">Looks</span> like you forgot to add <span class="hljs-type">any</span> inputs to your form

<span class="hljs-keyword">mixin</span> field(name, <span class="hljs-keyword">type</span>)
    label= name
    input(<span class="hljs-keyword">type</span>= <span class="hljs-keyword">type</span>, name= name)
</code></pre>
<pre><code class="lang-jade"><span class="hljs-comment">// login.jade</span>

<span class="hljs-keyword">include</span> mixins/form

+form(<span class="hljs-string">"auth/login"</span>, <span class="hljs-string">"post"</span>)
    +field(<span class="hljs-string">"email"</span>, <span class="hljs-string">"text"</span>)
    +field(<span class="hljs-string">"password"</span>, <span class="hljs-string">"password"</span>)
</code></pre>
<p>So that&#39;s pretty cool, but there&#39;s a lot more you can do with the field mixin. You can run any javascript inside jade, so we can add an <code>unslugify</code> function to convert &quot;email_address&quot; to &quot;Email Address&quot;. Then add in some input type guessing and we&#39;ve got something pretty useful really quickly.</p>
<pre><code class="lang-jade"><span class="hljs-comment">// mixins/form.jade</span>

<span class="hljs-comment">//- ...</span>

mixin field(name, <span class="hljs-class"><span class="hljs-keyword">type</span>)</span>
    <span class="hljs-comment">//- Convert "foo_bar" to "Foo Bar"</span>
    -var unslugify = <span class="hljs-keyword">function</span>(input) {
    -   <span class="hljs-keyword">return</span> input.charAt(<span class="hljs-number">0</span>).toUpperCase() + input.slice(<span class="hljs-number">1</span>).toLowerCase().replace(/[-|_](.)/g, <span class="hljs-keyword">function</span>(<span class="hljs-keyword">match</span>, group1) {
    -       <span class="hljs-keyword">return</span> ' ' + group1.toUpperCase();
    -   });
    -}

    <span class="hljs-comment">//- If no type has been set, try to pick an appropriate one</span>
    unless <span class="hljs-class"><span class="hljs-keyword">type</span></span>
        case name
            <span class="hljs-keyword">when</span> <span class="hljs-string">"password"</span>
                - <span class="hljs-class"><span class="hljs-keyword">type</span></span>= <span class="hljs-string">"password"</span>
            <span class="hljs-keyword">when</span> <span class="hljs-string">"password_confirmation"</span>
                - <span class="hljs-class"><span class="hljs-keyword">type</span></span>= <span class="hljs-string">"password"</span>
            <span class="hljs-keyword">when</span> <span class="hljs-string">"email"</span>
                - <span class="hljs-class"><span class="hljs-keyword">type</span></span>= <span class="hljs-string">"email"</span>
            <span class="hljs-keyword">default</span>
                - <span class="hljs-class"><span class="hljs-keyword">type</span></span>= <span class="hljs-string">"text"</span>

    div.field
        label= unslugify(name)
        input(<span class="hljs-class"><span class="hljs-keyword">type</span></span>= <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">name</span></span>= name)
</code></pre>
<pre><code class="lang-jade"><span class="hljs-comment">// login.jade</span>

<span class="hljs-keyword">include</span> mixins/form

+form(<span class="hljs-string">"auth/login"</span>, <span class="hljs-string">"post"</span>)
    +field(<span class="hljs-string">"email"</span>)
    +field(<span class="hljs-string">"password"</span>)
</code></pre>
<h2 id="lovely">Lovely</h2>
<p>There&#39;s a few more things you can do in jade, <a href="http://jade-lang.com/reference/">check out the reference</a> to see all your options. But hopefully you can see from this quick rundown how much cleaner you can make your views.</p>
<p>Coding should be fun and jade brings that enjoyment back to html.</p>


    <footer>
        <nav class="tags">
            
                <a class="tag tag-coding" href="/blog/tag/coding">coding</a></li>
            
                <a class="tag tag-javascript" href="/blog/tag/javascript">javascript</a></li>
            
                <a class="tag tag-node" href="/blog/tag/node">node</a></li>
            
                <a class="tag tag-jade" href="/blog/tag/jade">jade</a></li>
            
        </nav>

        <a class="comments-link" href="/blog/post/clean-your-html-with-jade#comments">Comments</a>
    </footer>
</article>
        
            <article class="post">
    <header>
        <h1><a href="/blog/post/easily-build-assets-with-gulpjs">Easily build assets with GulpJS</a></h1>

        <span class="date">15th February, 2014</span>
    </header>

    <p>I have spent so many hours trying to find the perfect build process for my less/sass stylesheets and coffeescripts. There are several php packages for this but I&#39;ve never been too happy with them and they often seem to fail for various and difficult to debug reasons.</p>
<p><a href="http://gulpjs.com">Gulpjs</a> is the answer to all your woes. It is a command-line tool that simply allows you to run build tasks.</p>
<!-- more -->

<h2 id="getting-started-with-gulp">Getting started with gulp</h2>
<p>Follow <a href="https://github.com/gulpjs/gulp/blob/master/docs/getting-started.md#getting-started">these instructions</a> to get gulp installed and running.</p>
<h3 id="plugins">Plugins</h3>
<p>There are numerous plugins available for gulp which provide all the functionality you could want.</p>
<p>You can install plugins through npm:</p>
<pre><code>npm <span class="hljs-operator"><span class="hljs-keyword">install</span> gulp-<span class="hljs-keyword">concat</span> gulp-coffee</span>
</code></pre><p>Then require them at the top of your <code>gulpfile.js</code>:</p>
<pre><code class="lang-js"><span class="hljs-keyword">var</span> <span class="hljs-keyword">concat</span> = <span class="hljs-keyword">require</span>(<span class="hljs-string">'gulp-concat'</span>);
<span class="hljs-keyword">var</span> coffee = <span class="hljs-keyword">require</span>(<span class="hljs-string">'gulp-coffee'</span>);
</code></pre>
<h3 id="writing-tasks">Writing tasks</h3>
<p>A good use case of gulp is compiling and combining coffeescripts in a single javascript file. So lets start with our first task:</p>
<pre><code class="lang-js">gulp.task(<span class="hljs-string">'coffeescripts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'assets/scripts/**/*.coffee'</span>)
        .pipe(concat(<span class="hljs-string">'combined.coffee'</span>))
        .pipe(coffee())
        .pipe(gulp.dest(<span class="hljs-string">'build/scripts/combined.js'</span>));
});
</code></pre>
<p>This task finds all <code>.coffee</code> files in any folder within your scripts directory. These are combined into a single file then piped into a plugin that compiles coffeescripts into javascript and finally pushed into your build directory.</p>
<p>It is important to combine your coffeescripts before compiling them. This will ensure that all your classes are defined within a single <code>(function() { ... })();</code> block and can easily reference each other without having to resort to the global <code>window</code> object.</p>
<p>You can run this task with <code>gulp coffeescripts</code> in your terminal.</p>
<h2 id="task-dependancies">Task dependancies</h2>
<p>So now you&#39;ve got your coffeescripts compiling, you may have some vendor javascripts that you want to also be built into the <code>combined.js</code> file. If you pipe these into your <code>coffee()</code> plugin you&#39;ll get a bunch of errors. Instead it is best to have a separate task that only runs on <code>.js</code> files.</p>
<pre><code>gulp.task(<span class="hljs-string">'coffeescripts'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'assets/scripts/**/*.coffee'</span>)
        .pipe(concat(<span class="hljs-string">'combined-coffee.coffee'</span>))
        .pipe(coffee())
        .pipe(gulp.dest(<span class="hljs-string">'assets/scripts/'</span>));
});

gulp.task(<span class="hljs-string">'scripts'</span>, [<span class="hljs-string">'coffeescripts'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> gulp.src(<span class="hljs-string">'assets/scripts/**/*.js'</span>)
        .pipe(concat(<span class="hljs-string">'combined.js'</span>))
        .pipe(uglify())
        .pipe(gulp.dest(<span class="hljs-string">'build/scripts'</span>));
});
</code></pre><p>By passing in <code>[&#39;coffeescripts&#39;]</code> to the <code>scripts</code> task you ensure it is run first. This compiles the coffeescripts into <code>combined-coffee.js</code> which is then combined with normal javascript files.</p>
<p>The uglify plugin minifies the scripts before they are piped into the build directory:</p>
<pre><code><span class="hljs-keyword">var</span> uglify = <span class="hljs-built_in">require</span>(<span class="hljs-string">'gulp-uglify'</span>)
</code></pre><p>Running <code>gulp scripts</code> will now run the coffeescripts and scripts tasks.</p>
<h2 id="watchers-and-automated-builds">Watchers and automated builds</h2>
<p>Having to run the gulp command every time you make a change to a file is a bit of a faff, this can be automated for you using watchers.</p>
<pre><code>gulp.task(<span class="hljs-symbol">'watc</span>h', function() {
    gulp.watch([
        <span class="hljs-symbol">'assets</span>/scripts<span class="hljs-javadoc">/**/*.coffee',
        'assets/scripts/**/</span>*.js'
    ], [<span class="hljs-symbol">'script</span>s']);

    gulp.watch([
        <span class="hljs-symbol">'assets</span>/styles<span class="hljs-javadoc">/**/*.sass',
        'assets/styles/**/</span>*.css'
    ], [<span class="hljs-symbol">'style</span>s']);
});
</code></pre><p>If any changes are made to one of the specified files, the related task will be run. You can start the watcher with:</p>
<pre><code><span class="hljs-title">gulp</span> watch
</code></pre><h2 id="taking-it-further">Taking it further</h2>
<p>There are <a href="http://gulpjs.com/plugins/">lot of existing plugins for gulp</a> and I&#39;d suggest taking some time to look through and see which ones might prove useful in your code environment.</p>
<p>This <a href="https://gist.github.com/lsjroberts/8810740">example build script</a> shows how I run my usual full build process, feel free it use it as you wish.</p>
<p>You may wish to install your dependancies through a <code>package.json</code> file and running <code>npm install</code> to ensure all your developers are working with the same node modules.</p>


    <footer>
        <nav class="tags">
            
                <a class="tag tag-coding" href="/blog/tag/coding">coding</a></li>
            
                <a class="tag tag-javascript" href="/blog/tag/javascript">javascript</a></li>
            
                <a class="tag tag-gulpjs" href="/blog/tag/gulpjs">gulpjs</a></li>
            
        </nav>

        <a class="comments-link" href="/blog/post/easily-build-assets-with-gulpjs#comments">Comments</a>
    </footer>
</article>
        
    </section>

    <nav class="pagination-wrapper">
    <ul class="pagination">
        
    </ul>
</nav>

        </div>
    </body>
</html>